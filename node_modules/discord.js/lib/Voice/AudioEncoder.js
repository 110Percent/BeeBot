"use strict";

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _child_process = require("child_process");

var _child_process2 = _interopRequireDefault(_child_process);

// no opus!

var _VolumeTransformer = require("./VolumeTransformer");

var _VolumeTransformer2 = _interopRequireDefault(_VolumeTransformer);

var opus;
try {
	opus = require("node-opus");
} catch (e) {}

var AudioEncoder = (function () {
	function AudioEncoder() {
		_classCallCheck(this, AudioEncoder);

		if (opus) {
			this.opus = new opus.OpusEncoder(48000, 2);
		}
		this.choice = false;
		this.sanityCheckPassed = undefined;
	}

	AudioEncoder.prototype.sanityCheck = function sanityCheck() {
		var _opus = this.opus;
		var encodeZeroes = function encodeZeroes() {
			try {
				var zeroes = new Buffer(1920);
				zeroes.fill(0);
				return _opus.encode(zeroes, 1920).readUIntBE(0, 3);
			} catch (err) {
				return false;
			}
		};
		if (this.sanityCheckPassed === undefined) this.sanityCheckPassed = encodeZeroes() === 16056318;
		return this.sanityCheckPassed;
	};

	AudioEncoder.prototype.opusBuffer = function opusBuffer(buffer) {

		return this.opus.encode(buffer, 1920);
	};

	AudioEncoder.prototype.getCommand = function getCommand(force) {
		if (this.choice && force) return choice;

		var choices = ["avconv", "ffmpeg"];

		for (var _iterator = choices, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
			var _ref;

			if (_isArray) {
				if (_i >= _iterator.length) break;
				_ref = _iterator[_i++];
			} else {
				_i = _iterator.next();
				if (_i.done) break;
				_ref = _i.value;
			}

			var choice = _ref;

			var p = _child_process2["default"].spawnSync(choice);
			if (!p.error) {
				this.choice = choice;
				return choice;
			}
		}

		return "help";
	};

	AudioEncoder.prototype.encodeStream = function encodeStream(stream, options) {
		var _this = this;

		return new Promise(function (resolve, reject) {
			_this.volume = new _VolumeTransformer2["default"](options.volume);

			var enc = _child_process2["default"].spawn(_this.getCommand(), ['-i', '-', '-f', 's16le', '-ar', '48000', '-ss', options.seek || 0, '-ac', 2, 'pipe:1']);

			var dest = stream.pipe(enc.stdin);

			dest.on('unpipe', function () {
				return dest.destroy();
			});
			dest.on('error', function (err) {
				return dest.destroy();
			});

			_this.hookEncodingProcess(resolve, reject, enc, stream);
		});
	};

	AudioEncoder.prototype.encodeFile = function encodeFile(file, options) {
		var _this2 = this;

		return new Promise(function (resolve, reject) {
			_this2.volume = new _VolumeTransformer2["default"](options.volume);

			var enc = _child_process2["default"].spawn(_this2.getCommand(), ['-i', file, '-f', 's16le', '-ar', '48000', '-ss', options.seek || 0, '-ac', 2, 'pipe:1']);

			_this2.hookEncodingProcess(resolve, reject, enc);
		});
	};

	AudioEncoder.prototype.encodeArbitraryFFmpeg = function encodeArbitraryFFmpeg(ffmpegOptions, volume) {
		var _this3 = this;

		return new Promise(function (resolve, reject) {
			_this3.volume = new _VolumeTransformer2["default"](volume);

			// add options discord.js needs
			var options = ffmpegOptions.concat(['-f', 's16le', '-ar', '48000', '-ac', 2, 'pipe:1']);
			var enc = _child_process2["default"].spawn(_this3.getCommand(), options);

			_this3.hookEncodingProcess(resolve, reject, enc);
		});
	};

	AudioEncoder.prototype.hookEncodingProcess = function hookEncodingProcess(resolve, reject, enc, stream) {
		var _this4 = this;

		var processKilled = false;

		function killProcess(cause) {
			if (processKilled) return;

			enc.stdin.pause();
			enc.kill("SIGKILL");

			processKilled = true;

			reject(cause);
		}

		var ffmpegErrors = "";

		enc.stdout.pipe(this.volume);

		enc.stderr.on("data", function (data) {
			ffmpegErrors += "\n" + new Buffer(data).toString().trim();
		});

		enc.stdout.once("end", function () {
			killProcess("end");
		});

		enc.stdout.once("error", function () {
			enc.stdout.emit("end");
		});

		enc.once("exit", function (code, signal) {
			if (code) {
				reject(new Error("FFMPEG: " + ffmpegErrors));
			}
		});

		this.volume.once("readable", function () {
			var data = {
				proc: enc,
				stream: _this4.volume,
				channels: 2
			};

			if (stream) {
				data.instream = stream;
			}

			resolve(data);
		});

		this.volume.once("end", function () {
			killProcess("end");
		});

		this.volume.once("error", function () {
			killProcess("end");
		});

		this.volume.on("end", function () {
			killProcess("end");
		});

		this.volume.on("close", function () {
			killProcess("close");
		});
	};

	return AudioEncoder;
})();

exports["default"] = AudioEncoder;
module.exports = exports["default"];
